// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StoneTreasure.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using scg = global::System.Collections.Generic;
namespace stonetreasure {

  #region Messages
  /// <summary>
  ///人物石阵当前石阵层数，请求
  /// </summary>
  public sealed class FloorInfoRequest : pb::IMessage {
    private static readonly pb::MessageParser<FloorInfoRequest> _parser = new pb::MessageParser<FloorInfoRequest>(() => new FloorInfoRequest());
    public static pb::MessageParser<FloorInfoRequest> Parser { get { return _parser; } }

    public void WriteTo(pb::CodedOutputStream output) {
    }

    public int CalculateSize() {
      int size = 0;
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  /// <summary>
  ///state为false时 第五个字段无值 人物石阵当前石阵层数，响应
  /// </summary>
  public sealed class FloorInfoResponse : pb::IMessage {
    private static readonly pb::MessageParser<FloorInfoResponse> _parser = new pb::MessageParser<FloorInfoResponse>(() => new FloorInfoResponse());
    public static pb::MessageParser<FloorInfoResponse> Parser { get { return _parser; } }

    private int floor_;
    /// <summary>
    ///int32 type = 1;	//1:普通层 2：特殊层 3：惊喜层
    /// </summary>
    public int floor {
      get { return floor_; }
      set {
        floor_ = value;
      }
    }

    private int stoneTypeId_;
    /// <summary>
    ///格子素材的id
    /// </summary>
    public int stoneTypeId {
      get { return stoneTypeId_; }
      set {
        stoneTypeId_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::stonetreasure.StoneReward> _repeated_stoneReward_codec
        = pb::FieldCodec.ForMessage(34, global::stonetreasure.StoneReward.Parser);
    private readonly pbc::RepeatedField<global::stonetreasure.StoneReward> stoneReward_ = new pbc::RepeatedField<global::stonetreasure.StoneReward>();
    public pbc::RepeatedField<global::stonetreasure.StoneReward> stoneReward {
      get { return stoneReward_; }
    }

    private static readonly pb::FieldCodec<global::stonetreasure.StateInfo> _repeated_stateInfo_codec
        = pb::FieldCodec.ForMessage(42, global::stonetreasure.StateInfo.Parser);
    private readonly pbc::RepeatedField<global::stonetreasure.StateInfo> stateInfo_ = new pbc::RepeatedField<global::stonetreasure.StateInfo>();
    /// <summary>
    ///state为true时 五个字段有值 返回上次未完成的石阵信息
    /// </summary>
    public pbc::RepeatedField<global::stonetreasure.StateInfo> stateInfo {
      get { return stateInfo_; }
    }

    private int stoneId_;
    /// <summary>
    ///用于获取石阵的几乘几
    /// </summary>
    public int stoneId {
      get { return stoneId_; }
      set {
        stoneId_ = value;
      }
    }

    private bool jingxiflag_;
    /// <summary>
    ///进入惊喜层时，客 户端动画只显示一次的标志位 默认为false：不显示动画，true时：显示动画
    /// </summary>
    public bool jingxiflag {
      get { return jingxiflag_; }
      set {
        jingxiflag_ = value;
      }
    }

    private int type_;
    /// <summary>
    ///用于判断是首次进入，还是进入下一层，1：首次进入 2：进入下一层 
    /// </summary>
    public int type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    private int jingxiCostNum_;
    /// <summary>
    ///惊喜层免费剩余次数
    /// </summary>
    public int jingxiCostNum {
      get { return jingxiCostNum_; }
      set {
        jingxiCostNum_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (floor != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(floor);
      }
      if (stoneTypeId != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(stoneTypeId);
      }
      stoneReward_.WriteTo(output, _repeated_stoneReward_codec);
      stateInfo_.WriteTo(output, _repeated_stateInfo_codec);
      if (stoneId != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(stoneId);
      }
      if (jingxiflag != false) {
        output.WriteRawTag(56);
        output.WriteBool(jingxiflag);
      }
      if (type != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(type);
      }
      if (jingxiCostNum != 0) {
        output.WriteRawTag(72);
        output.WriteInt32(jingxiCostNum);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (floor != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(floor);
      }
      if (stoneTypeId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(stoneTypeId);
      }
      size += stoneReward_.CalculateSize(_repeated_stoneReward_codec);
      size += stateInfo_.CalculateSize(_repeated_stateInfo_codec);
      if (stoneId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(stoneId);
      }
      if (jingxiflag != false) {
        size += 1 + 1;
      }
      if (type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(type);
      }
      if (jingxiCostNum != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(jingxiCostNum);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 16: {
            floor = input.ReadInt32();
            break;
          }
          case 24: {
            stoneTypeId = input.ReadInt32();
            break;
          }
          case 34: {
            stoneReward_.AddEntriesFrom(input, _repeated_stoneReward_codec);
            break;
          }
          case 42: {
            stateInfo_.AddEntriesFrom(input, _repeated_stateInfo_codec);
            break;
          }
          case 48: {
            stoneId = input.ReadInt32();
            break;
          }
          case 56: {
            jingxiflag = input.ReadBool();
            break;
          }
          case 64: {
            type = input.ReadInt32();
            break;
          }
          case 72: {
            jingxiCostNum = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///本层的奖励item
  /// </summary>
  public sealed class StoneReward : pb::IMessage {
    private static readonly pb::MessageParser<StoneReward> _parser = new pb::MessageParser<StoneReward>(() => new StoneReward());
    public static pb::MessageParser<StoneReward> Parser { get { return _parser; } }

    private int getNum_;
    /// <summary>
    ///以获得道具数量
    /// </summary>
    public int getNum {
      get { return getNum_; }
      set {
        getNum_ = value;
      }
    }

    private int itemId_;
    /// <summary>
    ///表Id
    /// </summary>
    public int itemId {
      get { return itemId_; }
      set {
        itemId_ = value;
      }
    }

    private int sum_;
    /// <summary>
    ///同一类型道具的总数
    /// </summary>
    public int sum {
      get { return sum_; }
      set {
        sum_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (getNum != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(getNum);
      }
      if (itemId != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(itemId);
      }
      if (sum != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(sum);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (getNum != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(getNum);
      }
      if (itemId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(itemId);
      }
      if (sum != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(sum);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            getNum = input.ReadInt32();
            break;
          }
          case 16: {
            itemId = input.ReadInt32();
            break;
          }
          case 24: {
            sum = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///state为true时，翻开的石块的信息
  /// </summary>
  public sealed class StateInfo : pb::IMessage {
    private static readonly pb::MessageParser<StateInfo> _parser = new pb::MessageParser<StateInfo>(() => new StateInfo());
    public static pb::MessageParser<StateInfo> Parser { get { return _parser; } }

    private string location_ = "";
    /// <summary>
    ///坐标 1#2 x：1 y:2
    /// </summary>
    public string location {
      get { return location_; }
      set {
        location_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private int itemId_;
    /// <summary>
    ///分为>0道具、0空白、-1深红色、-2浅红色、-3下一层 -5：空白格子
    /// </summary>
    public int itemId {
      get { return itemId_; }
      set {
        itemId_ = value;
      }
    }

    private int color_;
    /// <summary>
    ///  存在道具id>0或者itemid=-3时的时候才会用到这个字段 -1深红色、-2浅红色
    /// </summary>
    public int color {
      get { return color_; }
      set {
        color_ = value;
      }
    }

    private int itemNum_;
    /// <summary>
    ///道具的数量 道具id>0的时候为正确的堆叠数量，其余时候默认为0
    /// </summary>
    public int itemNum {
      get { return itemNum_; }
      set {
        itemNum_ = value;
      }
    }

    private int colorByRound_;
    /// <summary>
    ///itemid = 0时才用到，color字段显示周围8格的数量
    /// </summary>
    public int colorByRound {
      get { return colorByRound_; }
      set {
        colorByRound_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (location.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(location);
      }
      if (itemId != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(itemId);
      }
      if (color != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(color);
      }
      if (itemNum != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(itemNum);
      }
      if (colorByRound != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(colorByRound);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (location.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(location);
      }
      if (itemId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(itemId);
      }
      if (color != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(color);
      }
      if (itemNum != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(itemNum);
      }
      if (colorByRound != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(colorByRound);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            location = input.ReadString();
            break;
          }
          case 16: {
            itemId = input.ReadInt32();
            break;
          }
          case 24: {
            color = input.ReadInt32();
            break;
          }
          case 32: {
            itemNum = input.ReadInt32();
            break;
          }
          case 40: {
            colorByRound = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///击碎石块，请求
  /// </summary>
  public sealed class StoneLocationRequest : pb::IMessage {
    private static readonly pb::MessageParser<StoneLocationRequest> _parser = new pb::MessageParser<StoneLocationRequest>(() => new StoneLocationRequest());
    public static pb::MessageParser<StoneLocationRequest> Parser { get { return _parser; } }

    private string location_ = "";
    /// <summary>
    ///坐标 1#2 x：1 y:2
    /// </summary>
    public string location {
      get { return location_; }
      set {
        location_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (location.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(location);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (location.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(location);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            location = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///击碎石块，响应
  /// </summary>
  public sealed class StoneLocationResponse : pb::IMessage {
    private static readonly pb::MessageParser<StoneLocationResponse> _parser = new pb::MessageParser<StoneLocationResponse>(() => new StoneLocationResponse());
    public static pb::MessageParser<StoneLocationResponse> Parser { get { return _parser; } }

    private int itemId_;
    /// <summary>
    ///道具的表id  >0:有道具 0:无道具 -3:进入下一层
    /// </summary>
    public int itemId {
      get { return itemId_; }
      set {
        itemId_ = value;
      }
    }

    private int itemNum_;
    /// <summary>
    ///道具的数量 有道具时，显示正常数量（比如有堆叠的:99，装备:1）,无道具时（0，-1，-2，-3）显示数量为0
    /// </summary>
    public int itemNum {
      get { return itemNum_; }
      set {
        itemNum_ = value;
      }
    }

    private int color_;
    /// <summary>
    ///0:空白，-1:深红色，-2:浅红色 
    /// </summary>
    public int color {
      get { return color_; }
      set {
        color_ = value;
      }
    }

    private string location_ = "";
    /// <summary>
    ///坐标 1#2 x：1 y:2
    /// </summary>
    public string location {
      get { return location_; }
      set {
        location_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private int colorByRound_;
    /// <summary>
    ///itemid = 0时才用到，color字段显示周围8格的数量
    /// </summary>
    public int colorByRound {
      get { return colorByRound_; }
      set {
        colorByRound_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (itemId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(itemId);
      }
      if (itemNum != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(itemNum);
      }
      if (color != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(color);
      }
      if (location.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(location);
      }
      if (colorByRound != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(colorByRound);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (itemId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(itemId);
      }
      if (itemNum != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(itemNum);
      }
      if (color != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(color);
      }
      if (location.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(location);
      }
      if (colorByRound != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(colorByRound);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            itemId = input.ReadInt32();
            break;
          }
          case 16: {
            itemNum = input.ReadInt32();
            break;
          }
          case 24: {
            color = input.ReadInt32();
            break;
          }
          case 34: {
            location = input.ReadString();
            break;
          }
          case 40: {
            colorByRound = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///下一层的坐标信息，1.奖励全部领完时2.进入惊喜层时
  /// </summary>
  public sealed class DownLocationResponse : pb::IMessage {
    private static readonly pb::MessageParser<DownLocationResponse> _parser = new pb::MessageParser<DownLocationResponse>(() => new DownLocationResponse());
    public static pb::MessageParser<DownLocationResponse> Parser { get { return _parser; } }

    private string location_ = "";
    public string location {
      get { return location_; }
      set {
        location_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private int color_;
    /// <summary>
    ///0:空白，-1:深红色，-2:浅红色
    /// </summary>
    public int color {
      get { return color_; }
      set {
        color_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (location.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(location);
      }
      if (color != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(color);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (location.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(location);
      }
      if (color != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(color);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            location = input.ReadString();
            break;
          }
          case 16: {
            color = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///稀有、特殊、惊喜奖励领完时，返回普通奖励
  /// </summary>
  public sealed class GetNormalAndDownResponse : pb::IMessage {
    private static readonly pb::MessageParser<GetNormalAndDownResponse> _parser = new pb::MessageParser<GetNormalAndDownResponse>(() => new GetNormalAndDownResponse());
    public static pb::MessageParser<GetNormalAndDownResponse> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<global::stonetreasure.StateInfo> _repeated_stateInfo_codec
        = pb::FieldCodec.ForMessage(10, global::stonetreasure.StateInfo.Parser);
    private readonly pbc::RepeatedField<global::stonetreasure.StateInfo> stateInfo_ = new pbc::RepeatedField<global::stonetreasure.StateInfo>();
    public pbc::RepeatedField<global::stonetreasure.StateInfo> stateInfo {
      get { return stateInfo_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      stateInfo_.WriteTo(output, _repeated_stateInfo_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += stateInfo_.CalculateSize(_repeated_stateInfo_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            stateInfo_.AddEntriesFrom(input, _repeated_stateInfo_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///进入下一层的请求
  /// </summary>
  public sealed class DownStoneRequest : pb::IMessage {
    private static readonly pb::MessageParser<DownStoneRequest> _parser = new pb::MessageParser<DownStoneRequest>(() => new DownStoneRequest());
    public static pb::MessageParser<DownStoneRequest> Parser { get { return _parser; } }

    public void WriteTo(pb::CodedOutputStream output) {
    }

    public int CalculateSize() {
      int size = 0;
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
