// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Fight.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using scg = global::System.Collections.Generic;
namespace fight {

  #region Messages
  /// <summary>
  ///技能影响对象
  /// </summary>
  public sealed class EffectedTarget : pb::IMessage {
    private static readonly pb::MessageParser<EffectedTarget> _parser = new pb::MessageParser<EffectedTarget>(() => new EffectedTarget());
    public static pb::MessageParser<EffectedTarget> Parser { get { return _parser; } }

    private long id_;
    /// <summary>
    ///目标id
    /// </summary>
    public long id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    private int deltaHP_;
    /// <summary>
    ///hp变化,负数为掉血,正数为加血
    /// </summary>
    public int deltaHP {
      get { return deltaHP_; }
      set {
        deltaHP_ = value;
      }
    }

    private global::google.Int32Value hp_;
    /// <summary>
    ///变化后的hp
    /// </summary>
    public global::google.Int32Value hp {
      get { return hp_; }
      set {
        hp_ = value;
      }
    }

    private int newX_;
    /// <summary>
    ///冲撞改变位置技能以后的位置
    /// </summary>
    public int newX {
      get { return newX_; }
      set {
        newX_ = value;
      }
    }

    private int newY_;
    public int newY {
      get { return newY_; }
      set {
        newY_ = value;
      }
    }

    private int defenceDamage_;
    /// <summary>
    ///用护盾抵消的伤害
    /// </summary>
    public int defenceDamage {
      get { return defenceDamage_; }
      set {
        defenceDamage_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (id != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(id);
      }
      if (deltaHP != 0) {
        output.WriteRawTag(16);
        output.WriteSInt32(deltaHP);
      }
      if (hp_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(hp);
      }
      if (newX != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(newX);
      }
      if (newY != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(newY);
      }
      if (defenceDamage != 0) {
        output.WriteRawTag(72);
        output.WriteInt32(defenceDamage);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (id != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(id);
      }
      if (deltaHP != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(deltaHP);
      }
      if (hp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(hp);
      }
      if (newX != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(newX);
      }
      if (newY != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(newY);
      }
      if (defenceDamage != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(defenceDamage);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            id = input.ReadInt64();
            break;
          }
          case 16: {
            deltaHP = input.ReadSInt32();
            break;
          }
          case 26: {
            if (hp_ == null) {
              hp_ = new global::google.Int32Value();
            }
            input.ReadMessage(hp_);
            break;
          }
          case 48: {
            newX = input.ReadInt32();
            break;
          }
          case 56: {
            newY = input.ReadInt32();
            break;
          }
          case 72: {
            defenceDamage = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///技能效果
  /// </summary>
  public sealed class SkillEffect : pb::IMessage {
    private static readonly pb::MessageParser<SkillEffect> _parser = new pb::MessageParser<SkillEffect>(() => new SkillEffect());
    public static pb::MessageParser<SkillEffect> Parser { get { return _parser; } }

    private long performer_;
    /// <summary>
    ///技能的发动者
    /// </summary>
    public long performer {
      get { return performer_; }
      set {
        performer_ = value;
      }
    }

    private int skillId_;
    /// <summary>
    ///技能id
    /// </summary>
    public int skillId {
      get { return skillId_; }
      set {
        skillId_ = value;
      }
    }

    private int mp_;
    /// <summary>
    ///消耗后的mp
    /// </summary>
    public int mp {
      get { return mp_; }
      set {
        mp_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::fight.EffectedTarget> _repeated_targets_codec
        = pb::FieldCodec.ForMessage(34, global::fight.EffectedTarget.Parser);
    private readonly pbc::RepeatedField<global::fight.EffectedTarget> targets_ = new pbc::RepeatedField<global::fight.EffectedTarget>();
    /// <summary>
    ///技能影响的对象
    /// </summary>
    public pbc::RepeatedField<global::fight.EffectedTarget> targets {
      get { return targets_; }
    }

    private long time_;
    /// <summary>
    ///使用技能的时间
    /// </summary>
    public long time {
      get { return time_; }
      set {
        time_ = value;
      }
    }

    private static readonly pb::FieldCodec<long> _repeated_missedIds_codec
        = pb::FieldCodec.ForInt64(50);
    private readonly pbc::RepeatedField<long> missedIds_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///未击中的目标
    /// </summary>
    public pbc::RepeatedField<long> missedIds {
      get { return missedIds_; }
    }

    private long exp_;
    /// <summary>
    ///技能熟练度
    /// </summary>
    public long exp {
      get { return exp_; }
      set {
        exp_ = value;
      }
    }

    private int newX_;
    /// <summary>
    ///野蛮冲撞,瞬移后的位置
    /// </summary>
    public int newX {
      get { return newX_; }
      set {
        newX_ = value;
      }
    }

    private int newY_;
    public int newY {
      get { return newY_; }
      set {
        newY_ = value;
      }
    }

    private long mainTargetId_;
    /// <summary>
    ///主目标id,可能为0
    /// </summary>
    public long mainTargetId {
      get { return mainTargetId_; }
      set {
        mainTargetId_ = value;
      }
    }

    private int x_;
    /// <summary>
    ///技能释放地点,可能为0
    /// </summary>
    public int x {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    private int y_;
    public int y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    private static readonly pb::FieldCodec<long> _repeated_isCriticalIds_codec
        = pb::FieldCodec.ForInt64(106);
    private readonly pbc::RepeatedField<long> isCriticalIds_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///暴击目标
    /// </summary>
    public pbc::RepeatedField<long> isCriticalIds {
      get { return isCriticalIds_; }
    }

    private static readonly pb::FieldCodec<long> _repeated_immuPhyAttIds_codec
        = pb::FieldCodec.ForInt64(122);
    private readonly pbc::RepeatedField<long> immuPhyAttIds_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///免疫物理攻击的目标
    /// </summary>
    public pbc::RepeatedField<long> immuPhyAttIds {
      get { return immuPhyAttIds_; }
    }

    private int doubleHit_;
    /// <summary>
    ///是否连击技能效果;
    /// </summary>
    public int doubleHit {
      get { return doubleHit_; }
      set {
        doubleHit_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (performer != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(performer);
      }
      if (skillId != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(skillId);
      }
      if (mp != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(mp);
      }
      targets_.WriteTo(output, _repeated_targets_codec);
      if (time != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(time);
      }
      missedIds_.WriteTo(output, _repeated_missedIds_codec);
      if (exp != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(exp);
      }
      if (newX != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(newX);
      }
      if (newY != 0) {
        output.WriteRawTag(72);
        output.WriteInt32(newY);
      }
      if (mainTargetId != 0L) {
        output.WriteRawTag(80);
        output.WriteInt64(mainTargetId);
      }
      if (x != 0) {
        output.WriteRawTag(88);
        output.WriteInt32(x);
      }
      if (y != 0) {
        output.WriteRawTag(96);
        output.WriteInt32(y);
      }
      isCriticalIds_.WriteTo(output, _repeated_isCriticalIds_codec);
      immuPhyAttIds_.WriteTo(output, _repeated_immuPhyAttIds_codec);
      if (doubleHit != 0) {
        output.WriteRawTag(128, 1);
        output.WriteInt32(doubleHit);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (performer != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(performer);
      }
      if (skillId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(skillId);
      }
      if (mp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(mp);
      }
      size += targets_.CalculateSize(_repeated_targets_codec);
      if (time != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(time);
      }
      size += missedIds_.CalculateSize(_repeated_missedIds_codec);
      if (exp != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(exp);
      }
      if (newX != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(newX);
      }
      if (newY != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(newY);
      }
      if (mainTargetId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(mainTargetId);
      }
      if (x != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(x);
      }
      if (y != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(y);
      }
      size += isCriticalIds_.CalculateSize(_repeated_isCriticalIds_codec);
      size += immuPhyAttIds_.CalculateSize(_repeated_immuPhyAttIds_codec);
      if (doubleHit != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(doubleHit);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            performer = input.ReadInt64();
            break;
          }
          case 16: {
            skillId = input.ReadInt32();
            break;
          }
          case 24: {
            mp = input.ReadInt32();
            break;
          }
          case 34: {
            targets_.AddEntriesFrom(input, _repeated_targets_codec);
            break;
          }
          case 40: {
            time = input.ReadInt64();
            break;
          }
          case 50:
          case 48: {
            missedIds_.AddEntriesFrom(input, _repeated_missedIds_codec);
            break;
          }
          case 56: {
            exp = input.ReadInt64();
            break;
          }
          case 64: {
            newX = input.ReadInt32();
            break;
          }
          case 72: {
            newY = input.ReadInt32();
            break;
          }
          case 80: {
            mainTargetId = input.ReadInt64();
            break;
          }
          case 88: {
            x = input.ReadInt32();
            break;
          }
          case 96: {
            y = input.ReadInt32();
            break;
          }
          case 106:
          case 104: {
            isCriticalIds_.AddEntriesFrom(input, _repeated_isCriticalIds_codec);
            break;
          }
          case 122:
          case 120: {
            immuPhyAttIds_.AddEntriesFrom(input, _repeated_immuPhyAttIds_codec);
            break;
          }
          case 128: {
            doubleHit = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///攻击请求
  /// </summary>
  public sealed class UseSkillRequest : pb::IMessage {
    private static readonly pb::MessageParser<UseSkillRequest> _parser = new pb::MessageParser<UseSkillRequest>(() => new UseSkillRequest());
    public static pb::MessageParser<UseSkillRequest> Parser { get { return _parser; } }

    private int skillId_;
    /// <summary>
    ///技能id
    /// </summary>
    public int skillId {
      get { return skillId_; }
      set {
        skillId_ = value;
      }
    }

    private int x_;
    /// <summary>
    ///x,y 和 targetId 选填一个
    /// </summary>
    public int x {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    private int y_;
    public int y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    private long targetId_;
    public long targetId {
      get { return targetId_; }
      set {
        targetId_ = value;
      }
    }

    private long time_;
    public long time {
      get { return time_; }
      set {
        time_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (skillId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(skillId);
      }
      if (x != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(x);
      }
      if (y != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(y);
      }
      if (targetId != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(targetId);
      }
      if (time != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(time);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (skillId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(skillId);
      }
      if (x != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(x);
      }
      if (y != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(y);
      }
      if (targetId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(targetId);
      }
      if (time != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(time);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            skillId = input.ReadInt32();
            break;
          }
          case 16: {
            x = input.ReadInt32();
            break;
          }
          case 24: {
            y = input.ReadInt32();
            break;
          }
          case 32: {
            targetId = input.ReadInt64();
            break;
          }
          case 40: {
            time = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///技能信息
  /// </summary>
  public sealed class SkillInfo : pb::IMessage {
    private static readonly pb::MessageParser<SkillInfo> _parser = new pb::MessageParser<SkillInfo>(() => new SkillInfo());
    public static pb::MessageParser<SkillInfo> Parser { get { return _parser; } }

    private int sid_;
    public int sid {
      get { return sid_; }
      set {
        sid_ = value;
      }
    }

    private int level_;
    public int level {
      get { return level_; }
      set {
        level_ = value;
      }
    }

    private string name_ = "";
    public string name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private long exp_;
    public long exp {
      get { return exp_; }
      set {
        exp_ = value;
      }
    }

    private long lastUseTime_;
    public long lastUseTime {
      get { return lastUseTime_; }
      set {
        lastUseTime_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (sid != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(sid);
      }
      if (level != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(level);
      }
      if (name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(name);
      }
      if (exp != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(exp);
      }
      if (lastUseTime != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(lastUseTime);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (sid != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(sid);
      }
      if (level != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(level);
      }
      if (name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(name);
      }
      if (exp != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(exp);
      }
      if (lastUseTime != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(lastUseTime);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            sid = input.ReadInt32();
            break;
          }
          case 16: {
            level = input.ReadInt32();
            break;
          }
          case 26: {
            name = input.ReadString();
            break;
          }
          case 32: {
            exp = input.ReadInt64();
            break;
          }
          case 40: {
            lastUseTime = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  public sealed class BufferInfo : pb::IMessage {
    private static readonly pb::MessageParser<BufferInfo> _parser = new pb::MessageParser<BufferInfo>(() => new BufferInfo());
    public static pb::MessageParser<BufferInfo> Parser { get { return _parser; } }

    private int bufferId_;
    public int bufferId {
      get { return bufferId_; }
      set {
        bufferId_ = value;
      }
    }

    private long addTime_;
    public long addTime {
      get { return addTime_; }
      set {
        addTime_ = value;
      }
    }

    private long totalTime_;
    /// <summary>
    ///持续时间,毫秒数
    /// </summary>
    public long totalTime {
      get { return totalTime_; }
      set {
        totalTime_ = value;
      }
    }

    private int bufferValue_;
    public int bufferValue {
      get { return bufferValue_; }
      set {
        bufferValue_ = value;
      }
    }

    private long adder_;
    public long adder {
      get { return adder_; }
      set {
        adder_ = value;
      }
    }

    private int layer_;
    /// <summary>
    ///层数;为0删除;
    /// </summary>
    public int layer {
      get { return layer_; }
      set {
        layer_ = value;
      }
    }

    private long id_;
    public long id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (bufferId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(bufferId);
      }
      if (addTime != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(addTime);
      }
      if (totalTime != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(totalTime);
      }
      if (bufferValue != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(bufferValue);
      }
      if (adder != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(adder);
      }
      if (layer != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(layer);
      }
      if (id != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(id);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (bufferId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(bufferId);
      }
      if (addTime != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(addTime);
      }
      if (totalTime != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(totalTime);
      }
      if (bufferValue != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(bufferValue);
      }
      if (adder != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(adder);
      }
      if (layer != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(layer);
      }
      if (id != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(id);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            bufferId = input.ReadInt32();
            break;
          }
          case 16: {
            addTime = input.ReadInt64();
            break;
          }
          case 24: {
            totalTime = input.ReadInt64();
            break;
          }
          case 32: {
            bufferValue = input.ReadInt32();
            break;
          }
          case 40: {
            adder = input.ReadInt64();
            break;
          }
          case 48: {
            layer = input.ReadInt32();
            break;
          }
          case 56: {
            id = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  public sealed class DamagePosition : pb::IMessage {
    private static readonly pb::MessageParser<DamagePosition> _parser = new pb::MessageParser<DamagePosition>(() => new DamagePosition());
    public static pb::MessageParser<DamagePosition> Parser { get { return _parser; } }

    private int position_;
    /// <summary>
    ///装备位置
    /// </summary>
    public int position {
      get { return position_; }
      set {
        position_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (position != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(position);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (position != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(position);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            position = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///加buff或buff消失
  /// </summary>
  public sealed class BufferChanged : pb::IMessage {
    private static readonly pb::MessageParser<BufferChanged> _parser = new pb::MessageParser<BufferChanged>(() => new BufferChanged());
    public static pb::MessageParser<BufferChanged> Parser { get { return _parser; } }

    private long id_;
    public long id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    private global::fight.BufferInfo buffer_;
    public global::fight.BufferInfo buffer {
      get { return buffer_; }
      set {
        buffer_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (id != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(id);
      }
      if (buffer_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(buffer);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (id != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(id);
      }
      if (buffer_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(buffer);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            id = input.ReadInt64();
            break;
          }
          case 18: {
            if (buffer_ == null) {
              buffer_ = new global::fight.BufferInfo();
            }
            input.ReadMessage(buffer_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///buffer造成的持续伤害或持续治疗
  /// </summary>
  public sealed class BufferDeltaHP : pb::IMessage {
    private static readonly pb::MessageParser<BufferDeltaHP> _parser = new pb::MessageParser<BufferDeltaHP>(() => new BufferDeltaHP());
    public static pb::MessageParser<BufferDeltaHP> Parser { get { return _parser; } }

    private long id_;
    public long id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    private int deltaHP_;
    /// <summary>
    ///正数为加血,负数为掉血
    /// </summary>
    public int deltaHP {
      get { return deltaHP_; }
      set {
        deltaHP_ = value;
      }
    }

    private global::google.Int32Value hp_;
    /// <summary>
    ///变化后的hp
    /// </summary>
    public global::google.Int32Value hp {
      get { return hp_; }
      set {
        hp_ = value;
      }
    }

    private long adder_;
    public long adder {
      get { return adder_; }
      set {
        adder_ = value;
      }
    }

    private int bufferId_;
    public int bufferId {
      get { return bufferId_; }
      set {
        bufferId_ = value;
      }
    }

    private int defenceDamage_;
    /// <summary>
    ///用护盾抵消的伤害
    /// </summary>
    public int defenceDamage {
      get { return defenceDamage_; }
      set {
        defenceDamage_ = value;
      }
    }

    private bool isCritical_;
    /// <summary>
    ///是否暴击伤害;
    /// </summary>
    public bool isCritical {
      get { return isCritical_; }
      set {
        isCritical_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (id != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(id);
      }
      if (deltaHP != 0) {
        output.WriteRawTag(16);
        output.WriteSInt32(deltaHP);
      }
      if (hp_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(hp);
      }
      if (adder != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(adder);
      }
      if (bufferId != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(bufferId);
      }
      if (defenceDamage != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(defenceDamage);
      }
      if (isCritical != false) {
        output.WriteRawTag(64);
        output.WriteBool(isCritical);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (id != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(id);
      }
      if (deltaHP != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(deltaHP);
      }
      if (hp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(hp);
      }
      if (adder != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(adder);
      }
      if (bufferId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(bufferId);
      }
      if (defenceDamage != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(defenceDamage);
      }
      if (isCritical != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            id = input.ReadInt64();
            break;
          }
          case 16: {
            deltaHP = input.ReadSInt32();
            break;
          }
          case 26: {
            if (hp_ == null) {
              hp_ = new global::google.Int32Value();
            }
            input.ReadMessage(hp_);
            break;
          }
          case 32: {
            adder = input.ReadInt64();
            break;
          }
          case 48: {
            bufferId = input.ReadInt32();
            break;
          }
          case 56: {
            defenceDamage = input.ReadInt32();
            break;
          }
          case 64: {
            isCritical = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed class SkillIdInfo : pb::IMessage {
    private static readonly pb::MessageParser<SkillIdInfo> _parser = new pb::MessageParser<SkillIdInfo>(() => new SkillIdInfo());
    public static pb::MessageParser<SkillIdInfo> Parser { get { return _parser; } }

    private int skillId_;
    public int skillId {
      get { return skillId_; }
      set {
        skillId_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (skillId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(skillId);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (skillId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(skillId);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            skillId = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///技能升级结果消息,state=1 代表升级成功，0：表配置有错，升级失败，-1：玩家等级不满足要求;-2:技能消耗不满足条件
  /// </summary>
  public sealed class SCUpgradeSkillInfo : pb::IMessage {
    private static readonly pb::MessageParser<SCUpgradeSkillInfo> _parser = new pb::MessageParser<SCUpgradeSkillInfo>(() => new SCUpgradeSkillInfo());
    public static pb::MessageParser<SCUpgradeSkillInfo> Parser { get { return _parser; } }

    private int oldSkillId_;
    public int oldSkillId {
      get { return oldSkillId_; }
      set {
        oldSkillId_ = value;
      }
    }

    private int newSkillId_;
    public int newSkillId {
      get { return newSkillId_; }
      set {
        newSkillId_ = value;
      }
    }

    private int state_;
    public int state {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (oldSkillId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(oldSkillId);
      }
      if (newSkillId != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(newSkillId);
      }
      if (state != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(state);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (oldSkillId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(oldSkillId);
      }
      if (newSkillId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(newSkillId);
      }
      if (state != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(state);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            oldSkillId = input.ReadInt32();
            break;
          }
          case 16: {
            newSkillId = input.ReadInt32();
            break;
          }
          case 24: {
            state = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///保存技能快捷方式请求
  /// </summary>
  public sealed class SaveSkillShortCutRequest : pb::IMessage {
    private static readonly pb::MessageParser<SaveSkillShortCutRequest> _parser = new pb::MessageParser<SaveSkillShortCutRequest>(() => new SaveSkillShortCutRequest());
    public static pb::MessageParser<SaveSkillShortCutRequest> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<long> _repeated_skillShortCut_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> skillShortCut_ = new pbc::RepeatedField<long>();
    public pbc::RepeatedField<long> skillShortCut {
      get { return skillShortCut_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      skillShortCut_.WriteTo(output, _repeated_skillShortCut_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += skillShortCut_.CalculateSize(_repeated_skillShortCut_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            skillShortCut_.AddEntriesFrom(input, _repeated_skillShortCut_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///保存技能轮位置请求
  /// </summary>
  public sealed class SaveSkillPositionRequest : pb::IMessage {
    private static readonly pb::MessageParser<SaveSkillPositionRequest> _parser = new pb::MessageParser<SaveSkillPositionRequest>(() => new SaveSkillPositionRequest());
    public static pb::MessageParser<SaveSkillPositionRequest> Parser { get { return _parser; } }

    private int skillPosition_;
    public int skillPosition {
      get { return skillPosition_; }
      set {
        skillPosition_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (skillPosition != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(skillPosition);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (skillPosition != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(skillPosition);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            skillPosition = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///设置pk模式
  /// </summary>
  public sealed class SetPkModeRequest : pb::IMessage {
    private static readonly pb::MessageParser<SetPkModeRequest> _parser = new pb::MessageParser<SetPkModeRequest>(() => new SetPkModeRequest());
    public static pb::MessageParser<SetPkModeRequest> Parser { get { return _parser; } }

    private int pkMode_;
    /// <summary>
    ///0和平 1全体 2善恶 3组队 4帮会
    /// </summary>
    public int pkMode {
      get { return pkMode_; }
      set {
        pkMode_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (pkMode != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(pkMode);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (pkMode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(pkMode);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            pkMode = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///技能消失响应
  /// </summary>
  public sealed class RemoveSkillMsg : pb::IMessage {
    private static readonly pb::MessageParser<RemoveSkillMsg> _parser = new pb::MessageParser<RemoveSkillMsg>(() => new RemoveSkillMsg());
    public static pb::MessageParser<RemoveSkillMsg> Parser { get { return _parser; } }

    private int sid_;
    public int sid {
      get { return sid_; }
      set {
        sid_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (sid != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(sid);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (sid != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(sid);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            sid = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///装备技能信息
  /// </summary>
  public sealed class EquipSkillCoolDown : pb::IMessage {
    private static readonly pb::MessageParser<EquipSkillCoolDown> _parser = new pb::MessageParser<EquipSkillCoolDown>(() => new EquipSkillCoolDown());
    public static pb::MessageParser<EquipSkillCoolDown> Parser { get { return _parser; } }

    private int skillGroupId_;
    public int skillGroupId {
      get { return skillGroupId_; }
      set {
        skillGroupId_ = value;
      }
    }

    private long lastUseTime_;
    public long lastUseTime {
      get { return lastUseTime_; }
      set {
        lastUseTime_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (skillGroupId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(skillGroupId);
      }
      if (lastUseTime != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(lastUseTime);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (skillGroupId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(skillGroupId);
      }
      if (lastUseTime != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(lastUseTime);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            skillGroupId = input.ReadInt32();
            break;
          }
          case 16: {
            lastUseTime = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///玩家PK模式变更
  /// </summary>
  public sealed class PkModeChangedNtf : pb::IMessage {
    private static readonly pb::MessageParser<PkModeChangedNtf> _parser = new pb::MessageParser<PkModeChangedNtf>(() => new PkModeChangedNtf());
    public static pb::MessageParser<PkModeChangedNtf> Parser { get { return _parser; } }

    private int pkMode_;
    public int pkMode {
      get { return pkMode_; }
      set {
        pkMode_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (pkMode != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(pkMode);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (pkMode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(pkMode);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            pkMode = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///buff消失提醒
  /// </summary>
  public sealed class BufferRemoveRemindNtf : pb::IMessage {
    private static readonly pb::MessageParser<BufferRemoveRemindNtf> _parser = new pb::MessageParser<BufferRemoveRemindNtf>(() => new BufferRemoveRemindNtf());
    public static pb::MessageParser<BufferRemoveRemindNtf> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<int> _repeated_bufferId_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> bufferId_ = new pbc::RepeatedField<int>();
    public pbc::RepeatedField<int> bufferId {
      get { return bufferId_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      bufferId_.WriteTo(output, _repeated_bufferId_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += bufferId_.CalculateSize(_repeated_bufferId_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            bufferId_.AddEntriesFrom(input, _repeated_bufferId_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///清除技能CD通知
  /// </summary>
  public sealed class ClearSkillCDNtf : pb::IMessage {
    private static readonly pb::MessageParser<ClearSkillCDNtf> _parser = new pb::MessageParser<ClearSkillCDNtf>(() => new ClearSkillCDNtf());
    public static pb::MessageParser<ClearSkillCDNtf> Parser { get { return _parser; } }

    private int skillId_;
    public int skillId {
      get { return skillId_; }
      set {
        skillId_ = value;
      }
    }

    private long lastUseTime_;
    public long lastUseTime {
      get { return lastUseTime_; }
      set {
        lastUseTime_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (skillId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(skillId);
      }
      if (lastUseTime != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(lastUseTime);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (skillId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(skillId);
      }
      if (lastUseTime != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(lastUseTime);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            skillId = input.ReadInt32();
            break;
          }
          case 16: {
            lastUseTime = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///自动释放技能列表;
  /// </summary>
  public sealed class AutoSkillList : pb::IMessage {
    private static readonly pb::MessageParser<AutoSkillList> _parser = new pb::MessageParser<AutoSkillList>(() => new AutoSkillList());
    public static pb::MessageParser<AutoSkillList> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<int> _repeated_skillIds_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> skillIds_ = new pbc::RepeatedField<int>();
    public pbc::RepeatedField<int> skillIds {
      get { return skillIds_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      skillIds_.WriteTo(output, _repeated_skillIds_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += skillIds_.CalculateSize(_repeated_skillIds_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            skillIds_.AddEntriesFrom(input, _repeated_skillIds_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///设置自动释放技能状态
  /// </summary>
  public sealed class SkillAutoState : pb::IMessage {
    private static readonly pb::MessageParser<SkillAutoState> _parser = new pb::MessageParser<SkillAutoState>(() => new SkillAutoState());
    public static pb::MessageParser<SkillAutoState> Parser { get { return _parser; } }

    private int skillId_;
    public int skillId {
      get { return skillId_; }
      set {
        skillId_ = value;
      }
    }

    private int auto_;
    /// <summary>
    ///1,yes;2,no
    /// </summary>
    public int auto {
      get { return auto_; }
      set {
        auto_ = value;
      }
    }

    private int param_;
    /// <summary>
    ///客户端用参数;
    /// </summary>
    public int param {
      get { return param_; }
      set {
        param_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (skillId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(skillId);
      }
      if (auto != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(auto);
      }
      if (param != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(param);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (skillId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(skillId);
      }
      if (auto != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(auto);
      }
      if (param != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(param);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            skillId = input.ReadInt32();
            break;
          }
          case 16: {
            auto = input.ReadInt32();
            break;
          }
          case 24: {
            param = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class PlayerFsmState : pb::IMessage {
    private static readonly pb::MessageParser<PlayerFsmState> _parser = new pb::MessageParser<PlayerFsmState>(() => new PlayerFsmState());
    public static pb::MessageParser<PlayerFsmState> Parser { get { return _parser; } }

    private int state_;
    /// <summary>
    /// 2:active,3:fight
    /// </summary>
    public int state {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (state != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(state);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (state != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(state);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            state = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
